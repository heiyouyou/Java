一、多线程出现了安全问题：
问题的原因：
当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。
解决办法:
对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。
具体方法：
同步代码块    synchronized(obj){需要同步的代码} 
好处： 解决了多线程的安全性问题
弊端：多个线程每次需要判断锁，较为消耗资源

二、Synchronized的使用方法
多线程的安全性问题：
函数需要被对象所调用的，那么函数有一个所属对象的引用，就是this
所以同步函数使用的锁为this锁
总结：---》两个线程或者两个以上线程共同访问共享数据的时候，要保证两者持有同一把锁，才能保证数据的安全性
 注意:
 如果同步函数被静态修饰后，使用的锁是什么？
发现不是this锁，因为静态方法中不能有this关键字
静态进内存的时候，内存中没有本类的对象，一定有该类对应的字节码文件对象。  即类名.class（唯一），所以字节码文件锁属于静态同步方法的锁

三、互斥锁
在Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。
每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
关键字synchronized 来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。
同步的局限性：导致程序的执行效率要降低
同步方法（非静态的）的锁为this。
同步方法（静态的）的锁为当前类本身。

四、深刻理解synchronized
Java中每一个对象都有一个lock,当访问某个对象的synchronized方法时，该对象就会被上锁。
一个类中有synchronized方法，如果该类的对象的该方法被访问时，那么整个对象都被锁定了，但是整个意思是其他非synchronized方法和成员变量还是可以访问的，注意区分。
因为synchronized方法会锁定对象，所以一旦有一个synchronized方法被某个线程启动了，那么对象已经被独占了，其它的synchronized方法就不能再同时独占对象了，但是普通方法和成员变量并不独占对象，所以仍然可以被调用。

五、单例设计
Java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。
　单例模式有以下特点：
　1、单例类只能有一个实例。
　2、单例类必须自己创建自己的唯一实例。
　3、单例类必须给所有其他对象提供这一实例。
　单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。
这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。
五、懒汉式与饿汉式区别
1、两种方案的构造函数都是private私有的，类的实例为静态私有的。提供了一个public公有的静态方法给外界去访问。
2、但是饿汗式每次调用的时候不用做创建，直接返回已经创建好的实例对象。这样虽然节省了时间，但是却占用了空间，实例本身为static的，会一直在内存中带着。
3、懒汉式则是判断，在用的时候才会加载，会影响程序的执行速度。最关键的是，在并发情况下，懒汉式是不安全的。
4、如果两个线程，我们称之为线程1和线程2，在同一时间调用getInstance()方法，如果线程1先进入if语句块，然后线程2进行控制，那么就会有2个实例被创建。为了解决这样的并发线程的产生，我们采用synchronized解决此类问题。

六、释放锁的操作
1、当前线程的同步方法、同步代码块执行结束
2、当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
3、当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束
4、当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。

七、不会释放锁的操作
1、线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行
2、线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。应尽量避免使用suspend()和resume()来控制线程

八、线程的死锁问题
1、既然可以上锁，那么假如有2个线程，一个线程想先锁对象1，再锁对象2，恰好另外有一个线程先锁对象2，再锁对象1
2、在这个过程中，当线程1把对象1锁好以后，就想去锁对象2，但是不巧，线程2已经把对象2锁住了，也正在尝试去锁对象1
3、什么时候结束呢？只有线程1把2个对象都锁上并把方法执行完，并且线程2把2个对象也都锁上并且把方法执行完毕，那么就会结束，但是，谁都不肯放掉已经锁上的对象，所以就没有结果，这种情况就叫做线程的死锁。

九、线程通信
1、wait()：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问
2、notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待
3、notifyAll()：唤醒正在排队等待资源的所有线程结束等待.
Java.lang.Object提供的这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常
wait()方法：
在当前线程中调用方法：  对象名.wait()
使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。
调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）
调用此方法后，当前线程将释放对象监控权  ，然后进入等待
在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。

notify()/notifyAll()方法
在当前线程中调用方法：  对象名.notify()
功能：唤醒等待该对象监控权的一个线程。
调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）
